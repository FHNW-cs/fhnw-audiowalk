0, // INTRODUCTION FOR tr.state SCRIPTS;
1, //;
2, // CREATING CLIENTS;
3, //;
4, newClient 1;
5, newClient 2;
6, newClient 3;
7, //;
8, // EVERY LINE IN THE SCRIPT STARTS WITH nextState [int];
9, // FOLLOWED BY THE currentState [int] WHICH CAN ALSO BE WRITTEN IN UPPERCASE LETTERS;
10, // FOLLOWED BY THE CONDITIONS UNDER WHICH THE TRANSITION FROM currentState [int] TO nextState [int] TAKES PLACE;
11, //;
12, //;
13, // EVERY LINE CAN HOLD UP TO 20 CONDITIONS;
14, // IN MOST CASES 2 CONDITIONS SHOULD BE SUFFICIENT;
15, // THE SYNTAX IS keyword:conditionType[sym] args:depends on the conditionType[float or int or nothing];
16, //;
17, //;
18, // AFTER THE CONDITIONS FOLLOW THE MESSAGES TO BE SEND OUT OF trStates OUTLET;
19, // THE SYNTAX IS keyword:message[sym] keyword:receiver[sym] theMessage[sym];
20, // FINALLY YOU CAN ADD A WAIT MESSAGE WHICH DEFINES THE WAITING TIME AFTER WHICH THE NEW STATE WILL BE ENTERED;
21, //;
22, //;
23, //----- position [float x][float y][float width][float height] AS FLOATING POINT NUMBERS IS TRUE IF CLIENT IS WITHIN THE DESCRIBED RECTANGLE;
24, //----- timeOut [float timeOut] AFTER BEING IN STATE X FOR AT LEAST timeOut SECONDS IT BECOMES TRUE;
25, //-----;
26, nextState 1 CURRENTSTATE 0 position 0.4 0.4 0.2 0.2 message sender "/playSoundfile 1";
27, nextState 2 CURRENTSTATE 0 timeOut 10. message sender "first time out" wait 2.;
28, //-----;
29, //-----;
30, //----- !position [float x][float y][float width][float height] AS FLOATING POINT NUMBERS THE OPPOSITE OF position;
31, //-----;
32, //-----;
33, nextState 2 CURRENTSTATE 1 !position 0.4 0.4 0.2 0.2 message sender "/playSoundfile 2" wait 2.;
34, //-----;
35, //-----;
36, //----- positionChanged [float distance] IS TRUE IF CURRENTPOSITION-LASTPOSITION IS GREATER THAN distance;
37, //-----;
38, //-----;
39, nextState 3 CURRENTSTATE 2 numberOfSteps 20 message sender "playSoundfile 3" wait 2.;
40, //-----;
41, //-----;
42, //----- sitDown NO ARGUMENTS CURRENTLY ONLY AVAILABLE THROUGH THE SIMULATOR;
43, //----- getUp NO ARGUMENTS CURRENTLY ONLY AVAILABLE THROUGH THE SIMULATOR;
44, //-----;
45, //-----;
46, nextState 4 CURRENTSTATE 3 sitDown message sender "playSoundfile 4" wait 2.;
47, nextState 5 CURRENTSTATE 4 getUp message sender "playSoundfile 5" wait 2.;
48, //-----;
49, //-----;
50, //----- orientation [int orientationMin] [int orientationMax] THE ABSOLUTE ORIENTATION IN DEGREES QUANTIZED IN 15DEGREE STEPS;
51, //----- SECOND INTEGER IS OPTIONAL THEN THE RANGE IS DEFINED;
52, //-----;
53, //-----;
54, nextState 6 CURRENTSTATE 5 orientation 60 100 message sender "playSoundfile 6" wait 2.;
55, //-----;
56, //-----;
57, //----- orientationChanged [int orientationDelta] CURRENTORIENTATION - LASTORIENTATION MUST BE GREATER THAN DELTA;
58, //-----;
59, //-----;
60, nextState 7 CURRENTSTATE 6 orientationChanged 90 message sender "playSoundfile 7" wait 2.;
61, //-----;
62, //-----;
63, //----- rotation [int rotationDirection] TRUE IF ROTATION IS EITHER 1(CLOCKWISE) or -1(COUNTERCLOCKWISE);
64, //-----;
65, //-----;
66, nextState 8 CURRENTSTATE 7 orientation 300 rotation -1 message sender "playSoundfile 8" wait 2.;
67, nextState 9 CURRENTSTATE 8 orientation 90 rotation 1 message sender "playSoundfile 9" wait 2.;
68, //-----;
69, //-----;
70, //----- walkingDirection [int walkingDirection] TRUE IF WALKING DIRECTION IS THE SAME AS ORIENTATION(1) OR OPPOSITE(2);
71, //-----;
72, //-----;
73, nextState 10 CURRENTSTATE 9 walkingDirection 1 positionChanged 2. message sender "playSoundfile 10";
74, nextState 11 CURRENTSTATE 10 walkingDirection 2 positionChanged 2. message sender cmajor wait 2.;
75, //-----;
76, //-----;
77, //----- THE FOLLOWING CONTRUCT ALLOWS TO STAY IN THE SAME STATE WITHOUT TRIGGERING THE SAME MESSAGE OVER AND OVER AGAIN;
78, //-----;
79, //-----;
80, nextState -1 CURRENTSTATE 11 orientation 0 orientationChanged 15 message sender "playSoundfile 100";
81, nextState -1 CURRENTSTATE 11 orientation 30 orientationChanged 15 message sender "playSoundfile 101";
82, nextState -1 CURRENTSTATE 11 orientation 60 orientationChanged 15 message sender "playSoundfile 102";
83, nextState -1 CURRENTSTATE 11 orientation 90 orientationChanged 15 message sender "playSoundfile 103";
84, nextState -1 CURRENTSTATE 11 orientation 120 orientationChanged 15 message sender "playSoundfile 104";
85, nextState -1 CURRENTSTATE 11 orientation 150 orientationChanged 15 message sender "playSoundfile 105";
86, //-----;
87, //-----;
88, //----- If 180 degrees are reached before 15. seconds staying in state 11 we set flag 0 and go to state 12 otherwise flag 0 is not set;
89, //----- and we go back to the dreh modul;
90, //-----;
91, nextState 12 CURRENTSTATE 11 orientation 180 orientationChanged 15 setFlag 0 message sender "flag0 is set now" wait 2.;
92, nextState 12 CURRENTSTATE 11 timeOut 10. message sender "flag0 is not set" wait 2.;
93, nextState 13 CURRENTSTATE 12 timeOut 5. flag 0 message sender "flag0 is set, we go on";
94, nextState 11 CURRENTSTATE 12 timeOut 5. message sender "flag0 is not set, back to dreh";
95, //-----;
96, //-----;
97, //----- Independent of everything that happend before;
98, //----- after 150 seconds after start we go to state 1000;
99, //-----;
100, nextState 1000 maxOverallTime 150. noFlag 1 setFlag 1 message sender "overall time out";
101, //-----;
102, //-----;
103, //----- If already 2 timeouts occured;
104, //----- this message will be send once using a flag again;
105, //-----;
106, nextState -1 numberOfTimeOut noFlag 2 setFlag 2 message sender "2 timeOuts";
